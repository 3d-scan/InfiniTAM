// Copyright 2014-2015 Isis Innovation Limited and the authors of InfiniTAM

#include "ITMSurfelVisualisationEngine_CUDA.h"

#include "../Shared/ITMSurfelVisualisationEngine_Shared.h"

namespace ITMLib
{

//#################### CUDA KERNELS ####################

__global__ void ck_clear_surfel_index_image(int pixelCount, unsigned int *surfelIndexImage, int *depthBuffer)
{
  int locId = threadIdx.x + blockDim.x * blockIdx.x;
  if(locId < pixelCount)
  {
    clear_surfel_index_image(locId, surfelIndexImage, depthBuffer);
  }
}

#if DEBUG_CORRESPONDENCES
template <typename TSurfel>
__global__ void ck_copy_correspondences_to_buffer(int surfelCount, const TSurfel *surfels, float *correspondences)
{
  int surfelId = threadIdx.x + blockDim.x * blockIdx.x;
  if(surfelId < surfelCount)
  {
    copy_correspondences_to_buffer(surfelId, surfels, correspondences);
  }
}
#endif

template <typename TSurfel>
__global__ void ck_copy_scene_to_buffers(int surfelCount, const TSurfel *surfels, float *positions, unsigned char *normals, unsigned char *colours)
{
  int surfelId = threadIdx.x + blockDim.x * blockIdx.x;
  if(surfelId < surfelCount)
  {
    copy_surfel_to_buffers(surfelId, surfels, positions, normals, colours);
  }
}

template <typename TSurfel>
__global__ void ck_shade_pixel_colour(int pixelCount, const unsigned int *surfelIndexImage, const TSurfel *surfels, Vector4u *outputImage)
{
  int locId = threadIdx.x + blockDim.x * blockIdx.x;
  if(locId < pixelCount)
  {
    shade_pixel_colour(locId, surfelIndexImage, surfels, outputImage);
  }
}

template <typename TSurfel>
__global__ void ck_shade_pixel_depth(int pixelCount, const unsigned int *surfelIndexImage, const TSurfel *surfels, Vector3f cameraPosition,
                                     float *outputImage)
{
  int locId = threadIdx.x + blockDim.x * blockIdx.x;
  if(locId < pixelCount)
  {
    shade_pixel_depth(locId, surfelIndexImage, surfels, cameraPosition, outputImage);
  }
}

template <typename TSurfel>
__global__ void ck_shade_pixel_normal(int pixelCount, const unsigned int *surfelIndexImage, const TSurfel *surfels, Vector4u *outputImage)
{
  int locId = threadIdx.x + blockDim.x * blockIdx.x;
  if(locId < pixelCount)
  {
    shade_pixel_normal(locId, surfelIndexImage, surfels, outputImage);
  }
}

template <typename TSurfel>
__global__ void ck_update_depth_buffer_for_surfel(int surfelCount, const TSurfel *surfels, Matrix4f invT, ITMIntrinsics intrinsics,
                                                  int indexImageWidth, int indexImageHeight, int scaleFactor, int *depthBuffer)
{
  int surfelId = threadIdx.x + blockDim.x * blockIdx.x;
  if(surfelId < surfelCount)
  {
    update_depth_buffer_for_surfel(surfelId, surfels, invT, intrinsics, indexImageWidth, indexImageHeight, scaleFactor, depthBuffer);
  }
}

template <typename TSurfel>
__global__ void ck_update_index_image_for_surfel(int surfelCount, const TSurfel *surfels, Matrix4f invT, ITMIntrinsics intrinsics,
                                                 int indexImageWidth, int indexImageHeight, int scaleFactor, const int *depthBuffer,
                                                 unsigned int *surfelIndexImage)
{
  int surfelId = threadIdx.x + blockDim.x * blockIdx.x;
  if(surfelId < surfelCount)
  {
    update_index_image_for_surfel(surfelId, surfels, invT, intrinsics, indexImageWidth, indexImageHeight, scaleFactor, depthBuffer, surfelIndexImage);
  }
}

//#################### PUBLIC MEMBER FUNCTIONS ####################

#if DEBUG_CORRESPONDENCES
template <typename TSurfel>
void ITMSurfelVisualisationEngine_CUDA<TSurfel>::CopyCorrespondencesToBuffer(const ITMSurfelScene<TSurfel> *scene, float *correspondences) const
{
  const int surfelCount = static_cast<int>(scene->GetSurfelCount());

  int threadsPerBlock = 256;
  int numBlocks = (surfelCount + threadsPerBlock - 1) / threadsPerBlock;

  ck_copy_correspondences_to_buffer<<<numBlocks,threadsPerBlock>>>(
    surfelCount,
    scene->GetSurfels()->GetData(MEMORYDEVICE_CUDA),
    correspondences
  );
}
#endif

template <typename TSurfel>
void ITMSurfelVisualisationEngine_CUDA<TSurfel>::CopySceneToBuffers(const ITMSurfelScene<TSurfel> *scene, float *positions, unsigned char *normals, unsigned char *colours) const
{
  const int surfelCount = static_cast<int>(scene->GetSurfelCount());

  int threadsPerBlock = 256;
  int numBlocks = (surfelCount + threadsPerBlock - 1) / threadsPerBlock;

  ck_copy_scene_to_buffers<<<numBlocks,threadsPerBlock>>>(
    surfelCount,
    scene->GetSurfels()->GetData(MEMORYDEVICE_CUDA),
    positions,
    normals,
    colours
  );
}

template <typename TSurfel>
void ITMSurfelVisualisationEngine_CUDA<TSurfel>::RenderDepthImage(const ITMSurfelScene<TSurfel> *scene, const ITMPose *pose,
                                                                  const ITMSurfelRenderState *renderState, ITMFloatImage *outputImage) const
{
  const Vector3f cameraPosition = pose->GetT();
  float *outputImagePtr = outputImage->GetData(MEMORYDEVICE_CUDA);
  const int pixelCount = static_cast<int>(outputImage->dataSize);
  const unsigned int *surfelIndexImagePtr = renderState->GetIndexImage()->GetData(MEMORYDEVICE_CUDA);
  const TSurfel *surfels = scene->GetSurfels()->GetData(MEMORYDEVICE_CUDA);

  int threadsPerBlock = 256;
  int numBlocks = (pixelCount + threadsPerBlock - 1) / threadsPerBlock;

  ck_shade_pixel_depth<<<numBlocks,threadsPerBlock>>>(
    pixelCount,
    surfelIndexImagePtr,
    surfels,
    cameraPosition,
    outputImagePtr
  );
}

template <typename TSurfel>
void ITMSurfelVisualisationEngine_CUDA<TSurfel>::RenderImage(const ITMSurfelScene<TSurfel> *scene, const ITMSurfelRenderState *renderState,
                                                             ITMUChar4Image *outputImage, RenderImageType type) const
{
  // Prevent colour rendering if the surfels don't store colour information.
  if(type == Base::RENDER_COLOUR && !TSurfel::hasColourInformation) type = Base::RENDER_LAMBERTIAN;

  Vector4u *outputImagePtr = outputImage->GetData(MEMORYDEVICE_CUDA);
  const int pixelCount = static_cast<int>(outputImage->dataSize);
  const unsigned int *surfelIndexImagePtr = renderState->GetIndexImage()->GetData(MEMORYDEVICE_CUDA);
  const TSurfel *surfels = scene->GetSurfels()->GetData(MEMORYDEVICE_CUDA);

  int threadsPerBlock = 256;
  int numBlocks = (pixelCount + threadsPerBlock - 1) / threadsPerBlock;

  switch(type)
  {
    case Base::RENDER_COLOUR:
    {
      ck_shade_pixel_colour<<<numBlocks,threadsPerBlock>>>(
        pixelCount,
        surfelIndexImagePtr,
        surfels,
        outputImagePtr
      );
      break;
    }
    case Base::RENDER_LAMBERTIAN:
    {
      // TODO
      break;
    }
    case Base::RENDER_NORMAL:
    {
      ck_shade_pixel_normal<<<numBlocks,threadsPerBlock>>>(
        pixelCount,
        surfelIndexImagePtr,
        surfels,
        outputImagePtr
      );
      break;
    }
    default:
    {
      // TODO
      break;
    }
  }
}

//#################### PRIVATE MEMBER FUNCTIONS ####################

template <typename TSurfel>
MemoryDeviceType ITMSurfelVisualisationEngine_CUDA<TSurfel>::GetMemoryType() const
{
  return MEMORYDEVICE_CUDA;
}

template <typename TSurfel>
void ITMSurfelVisualisationEngine_CUDA<TSurfel>::MakeIndexImage(const ITMSurfelScene<TSurfel> *scene, const ITMPose *pose, const ITMIntrinsics *intrinsics,
                                                                int width, int height, int scaleFactor, unsigned int *surfelIndexImage, int *depthBuffer) const
{
  const int pixelCount = width * height;

  int threadsPerBlock = 256;
  int numBlocks = (pixelCount + threadsPerBlock - 1) / threadsPerBlock;

  ck_clear_surfel_index_image<<<numBlocks,threadsPerBlock>>>(
    pixelCount,
    surfelIndexImage,
    depthBuffer
  );

  const int surfelCount = static_cast<int>(scene->GetSurfelCount());
  numBlocks = (surfelCount + threadsPerBlock - 1) / threadsPerBlock;

  ck_update_depth_buffer_for_surfel<<<numBlocks,threadsPerBlock>>>(
    surfelCount,
    scene->GetSurfels()->GetData(MEMORYDEVICE_CUDA),
    pose->GetM(),
    *intrinsics,
    width,
    height,
    scaleFactor,
    depthBuffer
  );

  ck_update_index_image_for_surfel<<<numBlocks,threadsPerBlock>>>(
    surfelCount,
    scene->GetSurfels()->GetData(MEMORYDEVICE_CUDA),
    pose->GetM(),
    *intrinsics,
    width,
    height,
    scaleFactor,
    depthBuffer,
    surfelIndexImage
  );
}

}
