// Copyright 2014-2015 Isis Innovation Limited and the authors of InfiniTAM

#include "ITMMultiMeshingEngine_CUDA.h"

#include "../../../../ORUtils/CUDADefines.h"
#include "../../../Utils/ITMCUDAUtils.h"
#include "../Shared/ITMMeshingEngine_Shared.h"

using namespace ITMLib;

template<class TMultiVoxel, class TMultiIndex>
__global__ void meshScene_device(ITMMesh::Triangle *triangles, unsigned int *noTriangles_device, float factor, int noTotalEntries,
	int noMaxTriangles, const Vector4s *visibleBlockGlobalPos, const TMultiVoxel *localVBAs, const TMultiIndex *hashTables);

template<class TMultiIndex>
__global__ void findAllocateBlocks(Vector4s *visibleBlockGlobalPos, const TMultiIndex *hashTables, int noTotalEntries);

template<class TVoxel>
ITMMultiMeshingEngine_CUDA<TVoxel, ITMVoxelBlockHash>::ITMMultiMeshingEngine_CUDA(void)
{
	ORcudaSafeCall(cudaMalloc((void**)&visibleBlockGlobalPos_device, SDF_LOCAL_BLOCK_NUM * sizeof(Vector4s) * MAX_NUM_SCENES));
	ORcudaSafeCall(cudaMalloc((void**)&noTriangles_device, sizeof(unsigned int)));

	ORcudaSafeCall(cudaMalloc((void**)&indexData_device, sizeof(MultiIndexData)));
	ORcudaSafeCall(cudaMalloc((void**)&voxelData_device, sizeof(MultiVoxelData)));
}

template<class TVoxel>
ITMMultiMeshingEngine_CUDA<TVoxel, ITMVoxelBlockHash>::~ITMMultiMeshingEngine_CUDA(void)
{
	ORcudaSafeCall(cudaFree(visibleBlockGlobalPos_device));
	ORcudaSafeCall(cudaFree(noTriangles_device));

	ORcudaSafeCall(cudaFree(indexData_device));
	ORcudaSafeCall(cudaFree(voxelData_device));
}

template<class TVoxel>
void ITMMultiMeshingEngine_CUDA<TVoxel, ITMVoxelBlockHash>::MeshScene(ITMMesh *mesh, const ITMMultiSceneManager_instance<TVoxel, ITMVoxelBlockHash> & sceneManager)
{
	const ITMSceneParams & sceneParams = *(sceneManager.getScene(0)->scene->sceneParams);
	int numScenes = (int)sceneManager.numScenes();
	// prepare MultiIndex etc.
	{
		if (numScenes > MAX_NUM_SCENES) numScenes = MAX_NUM_SCENES;
		indexData_host.numScenes = numScenes;
		for (int sceneId = 0; sceneId < numScenes; ++sceneId) {
			indexData_host.poses_vs[sceneId] = sceneManager.getEstimatedGlobalPose(sceneId).GetM();
			indexData_host.poses_vs[sceneId].m30 /= sceneParams.voxelSize;
			indexData_host.poses_vs[sceneId].m31 /= sceneParams.voxelSize;
			indexData_host.poses_vs[sceneId].m32 /= sceneParams.voxelSize;
			indexData_host.posesInv[sceneId] = sceneManager.getEstimatedGlobalPose(sceneId).GetInvM();
			indexData_host.posesInv[sceneId].m30 /= sceneParams.voxelSize;
			indexData_host.posesInv[sceneId].m31 /= sceneParams.voxelSize;
			indexData_host.posesInv[sceneId].m32 /= sceneParams.voxelSize;
			indexData_host.index[sceneId] = sceneManager.getScene(sceneId)->scene->index.getIndexData();
			voxelData_host.voxels[sceneId] = sceneManager.getScene(sceneId)->scene->localVBA.GetVoxelBlocks();
		}

		ORcudaSafeCall(cudaMemcpy(indexData_device, &(indexData_host), sizeof(MultiIndexData), cudaMemcpyHostToDevice));
		ORcudaSafeCall(cudaMemcpy(voxelData_device, &(voxelData_host), sizeof(MultiVoxelData), cudaMemcpyHostToDevice));
	}

	ITMMesh::Triangle *triangles = mesh->triangles->GetData(MEMORYDEVICE_CUDA);

	typedef ITMMultiVoxel<TVoxel> VD;
	typedef ITMMultiIndex<ITMVoxelBlockHash> ID;

	int noMaxTriangles = mesh->noMaxTriangles, noTotalEntries = ITMVoxelBlockHash::noTotalEntries;
	float factor = sceneParams.voxelSize;

	ORcudaSafeCall(cudaMemset(noTriangles_device, 0, sizeof(unsigned int)));
	ORcudaSafeCall(cudaMemset(visibleBlockGlobalPos_device, 0, sizeof(Vector4s) * SDF_LOCAL_BLOCK_NUM));

	{ // identify used voxel blocks
		dim3 cudaBlockSize(256);
		dim3 gridSize((int)ceil((float)noTotalEntries / (float)cudaBlockSize.x), numScenes);

		findAllocateBlocks<typename ID::IndexData> << <gridSize, cudaBlockSize >> >(visibleBlockGlobalPos_device, indexData_device, noTotalEntries);
		ORcudaKernelCheck;
	}

	{ // mesh used voxel blocks
		dim3 cudaBlockSize(SDF_BLOCK_SIZE, SDF_BLOCK_SIZE, SDF_BLOCK_SIZE);
		dim3 gridSize(SDF_LOCAL_BLOCK_NUM / 16, 16, numScenes);

		meshScene_device<VD, typename ID::IndexData> << <gridSize, cudaBlockSize >> >(triangles, noTriangles_device, factor, noTotalEntries, noMaxTriangles,
			visibleBlockGlobalPos_device, voxelData_device, indexData_device);
		ORcudaKernelCheck;

		ORcudaSafeCall(cudaMemcpy(&mesh->noTotalTriangles, noTriangles_device, sizeof(unsigned int), cudaMemcpyDeviceToHost));
	}
}

template<class TMultiIndex>
__global__ void findAllocateBlocks(Vector4s *visibleBlockGlobalPos, const TMultiIndex *hashTables, int noTotalEntries)
{
	int entryId = threadIdx.x + blockIdx.x * blockDim.x;
	if (entryId > noTotalEntries - 1) return;

	ITMHashEntry *hashTable = hashTables->index[blockIdx.y];

	const ITMHashEntry &currentHashEntry = hashTable[entryId];

	if (currentHashEntry.ptr >= 0)
		visibleBlockGlobalPos[currentHashEntry.ptr + blockIdx.y * SDF_LOCAL_BLOCK_NUM] = Vector4s(currentHashEntry.pos.x, currentHashEntry.pos.y, currentHashEntry.pos.z, 1);
}


template<class TVoxel, class TIndex>
_CPU_AND_GPU_CODE_ inline bool findPointNeighbors2(THREADPTR(Vector3f) *p, THREADPTR(float) *sdf, Vector3i blockLocation, const CONSTPTR(TVoxel) *localVBA,
	const CONSTPTR(TIndex) *hashTables)
{
	int hashTableIdx = blockIdx.z;
	int vmIndex; Vector3i localBlockLocation;

	ITMMultiCache cache;

	localBlockLocation = blockLocation + Vector3i(0, 0, 0);
	p[0] = hashTables->posesInv[hashTableIdx] * localBlockLocation.toFloat();
	sdf[0] = readFromSDF_float_interpolated(localVBA, hashTables, p[0], vmIndex, cache);
	if (!vmIndex || sdf[0] == 1.0f) return false;

	localBlockLocation = blockLocation + Vector3i(1, 0, 0);
	p[1] = hashTables->posesInv[hashTableIdx] * localBlockLocation.toFloat();
	sdf[1] = readFromSDF_float_interpolated(localVBA, hashTables, p[1], vmIndex, cache);
	if (!vmIndex || sdf[1] == 1.0f) return false;

	localBlockLocation = blockLocation + Vector3i(1, 1, 0);
	p[2] = hashTables->posesInv[hashTableIdx] * localBlockLocation.toFloat();
	sdf[2] = readFromSDF_float_interpolated(localVBA, hashTables, p[2], vmIndex, cache);
	if (!vmIndex || sdf[2] == 1.0f) return false;

	localBlockLocation = blockLocation + Vector3i(0, 1, 0);
	p[3] = hashTables->posesInv[hashTableIdx] * localBlockLocation.toFloat();
	sdf[3] = readFromSDF_float_interpolated(localVBA, hashTables, p[3], vmIndex, cache);
	if (!vmIndex || sdf[3] == 1.0f) return false;

	localBlockLocation = blockLocation + Vector3i(0, 0, 1);
	p[4] = hashTables->posesInv[hashTableIdx] * localBlockLocation.toFloat();
	sdf[4] = readFromSDF_float_interpolated(localVBA, hashTables, p[4], vmIndex, cache);
	if (!vmIndex || sdf[4] == 1.0f) return false;

	localBlockLocation = blockLocation + Vector3i(1, 0, 1);
	p[5] = hashTables->posesInv[hashTableIdx] * localBlockLocation.toFloat();
	sdf[5] = readFromSDF_float_interpolated(localVBA, hashTables, p[5], vmIndex, cache);
	if (!vmIndex || sdf[5] == 1.0f) return false;

	localBlockLocation = blockLocation + Vector3i(1, 1, 1);
	p[6] = hashTables->posesInv[hashTableIdx] * localBlockLocation.toFloat();
	sdf[6] = readFromSDF_float_interpolated(localVBA, hashTables, p[6], vmIndex, cache);
	if (!vmIndex || sdf[6] == 1.0f) return false;

	localBlockLocation = blockLocation + Vector3i(0, 1, 1);
	p[7] = hashTables->posesInv[hashTableIdx] * localBlockLocation.toFloat();
	sdf[7] = readFromSDF_float_interpolated(localVBA, hashTables, p[7], vmIndex, cache);
	if (!vmIndex || sdf[7] == 1.0f) return false;

	return true;
}

template<class TVoxel, class TIndex>
_CPU_AND_GPU_CODE_ inline int buildVertList2(THREADPTR(Vector3f) *vertList, Vector3i globalPos, Vector3i localPos, const CONSTPTR(TVoxel) *localVBA, const CONSTPTR(TIndex) *hashTable)
{
	Vector3f points[8]; float sdfVals[8];

	if (!findPointNeighbors2(points, sdfVals, globalPos + localPos, localVBA, hashTable)) return -1;

	int cubeIndex = 0;
	if (sdfVals[0] < 0) cubeIndex |= 1; if (sdfVals[1] < 0) cubeIndex |= 2;
	if (sdfVals[2] < 0) cubeIndex |= 4; if (sdfVals[3] < 0) cubeIndex |= 8;
	if (sdfVals[4] < 0) cubeIndex |= 16; if (sdfVals[5] < 0) cubeIndex |= 32;
	if (sdfVals[6] < 0) cubeIndex |= 64; if (sdfVals[7] < 0) cubeIndex |= 128;

	if (edgeTable[cubeIndex] == 0) return -1;

	if (edgeTable[cubeIndex] & 1) vertList[0] = sdfInterp(points[0], points[1], sdfVals[0], sdfVals[1]);
	if (edgeTable[cubeIndex] & 2) vertList[1] = sdfInterp(points[1], points[2], sdfVals[1], sdfVals[2]);
	if (edgeTable[cubeIndex] & 4) vertList[2] = sdfInterp(points[2], points[3], sdfVals[2], sdfVals[3]);
	if (edgeTable[cubeIndex] & 8) vertList[3] = sdfInterp(points[3], points[0], sdfVals[3], sdfVals[0]);
	if (edgeTable[cubeIndex] & 16) vertList[4] = sdfInterp(points[4], points[5], sdfVals[4], sdfVals[5]);
	if (edgeTable[cubeIndex] & 32) vertList[5] = sdfInterp(points[5], points[6], sdfVals[5], sdfVals[6]);
	if (edgeTable[cubeIndex] & 64) vertList[6] = sdfInterp(points[6], points[7], sdfVals[6], sdfVals[7]);
	if (edgeTable[cubeIndex] & 128) vertList[7] = sdfInterp(points[7], points[4], sdfVals[7], sdfVals[4]);
	if (edgeTable[cubeIndex] & 256) vertList[8] = sdfInterp(points[0], points[4], sdfVals[0], sdfVals[4]);
	if (edgeTable[cubeIndex] & 512) vertList[9] = sdfInterp(points[1], points[5], sdfVals[1], sdfVals[5]);
	if (edgeTable[cubeIndex] & 1024) vertList[10] = sdfInterp(points[2], points[6], sdfVals[2], sdfVals[6]);
	if (edgeTable[cubeIndex] & 2048) vertList[11] = sdfInterp(points[3], points[7], sdfVals[3], sdfVals[7]);

	return cubeIndex;
}


template<class TMultiVoxel, class TMultiIndex>
__global__ void meshScene_device(ITMMesh::Triangle *triangles, unsigned int *noTriangles_device, float factor, int noTotalEntries,
	int noMaxTriangles, const Vector4s *visibleBlockGlobalPos, const TMultiVoxel *localVBAs, const TMultiIndex *hashTables)
{
	const Vector4s globalPos_4s = visibleBlockGlobalPos[blockIdx.x + gridDim.x * blockIdx.y + blockIdx.z * SDF_LOCAL_BLOCK_NUM];

	if (globalPos_4s.w == 0) return;

	Vector3i globalPos = Vector3i(globalPos_4s.x, globalPos_4s.y, globalPos_4s.z) * SDF_BLOCK_SIZE;

	Vector3f vertList[12];
	int cubeIndex = buildVertList2(vertList, globalPos, Vector3i(threadIdx.x, threadIdx.y, threadIdx.z), localVBAs, hashTables);

	if (cubeIndex < 0) return;

	for (int i = 0; triangleTable[cubeIndex][i] != -1; i += 3)
	{
		int triangleId = atomicAdd(noTriangles_device, 1);

		if (triangleId < noMaxTriangles - 1)
		{
			triangles[triangleId].p0 = vertList[triangleTable[cubeIndex][i]] * factor;
			triangles[triangleId].p1 = vertList[triangleTable[cubeIndex][i + 1]] * factor;
			triangles[triangleId].p2 = vertList[triangleTable[cubeIndex][i + 2]] * factor;
		}
	}
}